\chapter{Grundlagen}
\label{ch:fundamentals}

Dieses Kapitel möchte einige Grundlagen definieren, welche im Kapitel \ref{ch:main-matter} vorausgesetzt werden.
Es handelt von der Definition des funktionalen Programmier-Paradigmas, welches in den Sprachen Clojure und Elm zum Einsatz kommt.
Weiterhin werden die Webtechnologien Websockets und \acp{SPA} erklärt, welche das Frontend des \nameref{ch:main-matter}'s nutzt. 
Die Architektur der ganzen Applikation wird maßgebend durch die Trennung in unabängige Microservices beeinflusst, welche mit Docker realisiert ist.
Als Integrationspunkt fungiert Apache Kafka, welches ebenso in diesen Kapitel erklärt wird.
\section{Funktionale Programmierung}
Die funktionale Programmierung gehört zu den Deklarativen Programmierparadigmen und stellt neben der imperativen und objektorientierten Programmierung eines der am Häufigsten genutzten Paradigmen dar.
Anders als bei imperativen Sprachen, unterscheiden sich funktionale Sprachen vor Allem an ihrer Unveränderbarkeit von Variablen. 
Es wird dabei angestrebt, bei einer Veränderung des Zustandes einer Variablen nicht den Inhalt dessen Referenz zu verändern, sondern stattdessen eine Kopie zurückzuliefern.
Es wurde gezeigt, dass dies ebenso sehr performant funktionieren kann (TODO: add quote).
\par

\section{Verwendete Programmiersprachen}
\subsection{Clojure}
\blindtext
\par
\blindtext
\subsection{Elm}
\blindtext
\par
\blindtext
\section{Eingesetzte Webtechnologien}
\subsection{Websockets}
\blindtext
\subsection{\aclp{SPA}}
\blindtext
\section{Microservices}
\blindtext
\section{Container-Virtualisierung mit Docker}
\begin{figure}
  \centering
  \includegraphics[scale=0.75]{docker.pdf}
  \par
  \caption{Schichten einer Virtualisierung mit Docker}
  \label{fig:layers-docker}
\end{figure}
Docker\footnote{\url{https://docs.docker.com/}} ist eine Software zum Deployment von Applikationen innerhalb von Containern.
Im Vergleich zu \acp{VM}, ähnelt sich die Vorgehensweise, jedoch laufen die Prozesse der Container direkt auf dem Host-Betriebssystem.
Trotz dieser Tatsache sind die Prozesse mithilfe von \ac{u.A.} Control-Groups und Kernel Namespaces voneinander isoliert.
Weiterhin hat man die Möglichkeit mit gängigen Mandatory-Access-Control-Frameworks wie SE-Linux oder App-Armor die Rechte innerhalb der Container zu beschränken.
Als Anforderung besteht keine spezifische Hardware-Infrastruktur wie bei beispielsweise VMWare ESXi.
Ebenso ist Docker mittlerweile auf allen gängigen Betriebssystemen lauffähig, wobei Linux-Derivate die beste Unterstützung erhalten.
Dies ist damit begründet, dass die Docker-Engine (\ac{Abb.}~\ref{fig:layers-docker}) auf den einzelnen Betriebssystemen verschieden aussieht.
\par
Ein Container wird mithilfe eines Dockerfiles beschrieben.
Darin werden deskriptive Instruktionen definiert um Abhängigkeiten zu installieren, Konfigurationen vorzunehmen und andere Build-Steps auszuführen.
Ein spezifischer Container wird als Image bezeichnet und setzt sich aus granularen Sub-Images zusammen.
Beim Erzeugen von Images eigener Dockerfiles müssen im Vergleich zu \acp{VM} keine großen Dateien transferiert werden, da sie aus ihrem Rezept reproduzierbar sind. 
Es besteht auch die Möglichkeit, von anderen Dockerfiles zu erben und diese über das Netzwerk verteilt bereitzustellen.
Falls die über eine Docker-Registry angebotenen Schichten eines Containers noch nicht auf dem eigenen Rechner vorhanden sind, so werden diese heruntergeladen.
\par
Weiterhin gibt es einen entscheidenden Vorteil gegenüber einer traditionellen \ac{VM}: Ein Dockerfile trägt implizit zur Dokumentation bei, da jede Änderung an einem Container in seinem Rezept ergänzt werden muss, um diese bei einem erneuten Start \ac{bzw.} erneuten Build zu erhalten.
\par
Wird eine Applikation in einzelnen Services aufgeteilt, so bietet sich das Tool \textbf{Docker-Compose}\footnote{\url{https://docs.docker.com/compose/overview/}} an.
Es ermöglicht in einer einzelnen Datei (\texttt{docker-\break compose.yml}) alle Konfigurations-Parameter der einzelnen Containern zu definieren.
Das können \ac{bspw.} Volume-Mounts, Ports, Environment-Variables oder Netzwerke sein, welche sonst bei jedem \texttt{docker exec} Command angegeben werden müssten.
Alternativ dazu stünden eigene und oft fehlerintensive Shell-Scripts um ähnliches zu erreichen. 
\par
Es bietet sich auch an, getrennte Environments für Development, Test und Production als zentrale Dokumentation der Applikation zu nutzen (\texttt{docker-\break compose.[env].yml}).

\section{Apache Kafka}
Zwei\footnote{\url{https://kafka.apache.org/documentation/}}
\par
\blindtext
\par
\blindtext

